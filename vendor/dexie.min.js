/*! Dexie.js v3.2.4 - IndexedDB Wrapper Library */
/* This is a placeholder for the actual Dexie.js library */
/* In production, download the actual dexie.min.js from https://unpkg.com/dexie@3.2.4/dist/dexie.min.js */

(function() {
    'use strict';
    
    // Simple Dexie.js mock for development
    // Replace this with the actual Dexie library in production
    
    class MockDexie {
        constructor(name) {
            this.name = name;
            this._stores = {};
            this._data = {};
        }
        
        version(v) {
            return {
                stores: (schema) => {
                    this._stores = schema;
                    Object.keys(schema).forEach(storeName => {
                        this._data[storeName] = [];
                        this[storeName] = new MockTable(storeName, this._data);
                    });
                    return this;
                }
            };
        }
        
        transaction(mode, stores, callback) {
            return callback();
        }
    }
    
    class MockTable {
        constructor(name, data) {
            this.name = name;
            this._data = data;
            this._nextId = 1;
        }
        
        add(item) {
            return new Promise((resolve) => {
                if (!item.id) {
                    item.id = this._nextId++;
                }
                this._data[this.name].push(item);
                resolve(item.id);
            });
        }
        
        put(item) {
            return new Promise((resolve) => {
                const existing = this._data[this.name].find(x => x.id === item.id);
                if (existing) {
                    Object.assign(existing, item);
                } else {
                    if (!item.id) item.id = this._nextId++;
                    this._data[this.name].push(item);
                }
                resolve(item.id);
            });
        }
        
        get(id) {
            return Promise.resolve(this._data[this.name].find(x => x.id === id));
        }
        
        where(field) {
            return {
                equals: (value) => {
                    const results = this._data[this.name].filter(x => x[field] === value);
                    return {
                        first: () => Promise.resolve(results[0]),
                        count: () => Promise.resolve(results.length),
                        toArray: () => Promise.resolve(results),
                        and: (predicate) => {
                            const filtered = results.filter(predicate);
                            return {
                                toArray: () => Promise.resolve(filtered),
                                count: () => Promise.resolve(filtered.length)
                            };
                        }
                    };
                },
                below: (value) => {
                    const results = this._data[this.name].filter(x => x[field] < value);
                    return {
                        and: (predicate) => {
                            const filtered = results.filter(predicate);
                            return {
                                toArray: () => Promise.resolve(filtered)
                            };
                        },
                        toArray: () => Promise.resolve(results)
                    };
                },
                between: (lower, upper, includeLower, includeUpper) => {
                    const results = this._data[this.name].filter(x => {
                        const val = x[field];
                        const lowerCheck = includeLower ? val >= lower : val > lower;
                        const upperCheck = includeUpper ? val <= upper : val < upper;
                        return lowerCheck && upperCheck;
                    });
                    return {
                        and: (predicate) => {
                            const filtered = results.filter(predicate);
                            return {
                                toArray: () => Promise.resolve(filtered)
                            };
                        },
                        toArray: () => Promise.resolve(results)
                    };
                }
            };
        }
        
        orderBy(field) {
            return {
                reverse: () => {
                    const sorted = [...this._data[this.name]].sort((a, b) => {
                        return b[field] > a[field] ? 1 : -1;
                    });
                    return {
                        limit: (n) => {
                            return {
                                toArray: () => Promise.resolve(sorted.slice(0, n))
                            };
                        },
                        toArray: () => Promise.resolve(sorted)
                    };
                },
                toArray: () => {
                    const sorted = [...this._data[this.name]].sort((a, b) => {
                        return a[field] > b[field] ? 1 : -1;
                    });
                    return Promise.resolve(sorted);
                }
            };
        }
        
        toArray() {
            return Promise.resolve([...this._data[this.name]]);
        }
        
        count() {
            return Promise.resolve(this._data[this.name].length);
        }
        
        update(id, changes) {
            return new Promise((resolve) => {
                const item = this._data[this.name].find(x => x.id === id);
                if (item) {
                    Object.assign(item, changes);
                    resolve(1);
                } else {
                    resolve(0);
                }
            });
        }
        
        clear() {
            return new Promise((resolve) => {
                this._data[this.name] = [];
                resolve();
            });
        }
        
        bulkAdd(items) {
            return new Promise((resolve) => {
                items.forEach(item => {
                    if (!item.id) item.id = this._nextId++;
                    this._data[this.name].push(item);
                });
                resolve();
            });
        }
    }
    
    // Export as global Dexie
    if (typeof window !== 'undefined') {
        window.Dexie = MockDexie;
    }
    
    // Also export as module
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = MockDexie;
    }
    
})();

// Note: This is a simplified mock implementation
// For production use, replace this file with the actual Dexie.js library:
// Download from: https://unpkg.com/dexie@3.2.4/dist/dexie.min.js